---
layout: post
title: "C++ Primer"       # Title of the post
subtitle:
modified: 2017-01-24                 # Date
date:       2017-01-24 22:00:00
author:     "随机漫步的傻瓜"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 其他
---

# 第一章 开始
- main函数的返回类型必须为int,即整数类型。在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型
- iostream库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。
- 标准库定义了4个IO对象。为了处理输入，我们使用一个名为cin的istream类型的对象。这个对象也被称为标准输入。对于输出，我们使用一个名为cout的ostream类型的对象。此对象也被称为标准输出。标准库还定义了其他两个ostream对象，名为cerr和clog。我们通常用cerr来输出警告和错误消息，因此它也被称为标准错误。而clog用来输出程序运行时的一般性消息
- <<为输出运算符，该运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即，计算结果就是我们写入给定值的那个ostream对象
- 写入endl的效果就是结束当前行
- 输入运算符(>>)与输出运算符类似，它接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。与输出运算符类似，输入运算符返回其左侧运算对象作为其计算结果。
- while(std::cin >> value)可以用来判断输入是否结束
- 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效输入时，istream对象的状态会变为无效。处于无效状态的istream对象会使得条件变为假。
- 包含来自标准库的头文件时，也应该用尖括号(<>)包围头文件名。对于不属于标准库的头文件，则用双引号("")包围
- C++有两种类型的注释：单行注释和界定符对注释。单行注释以//开始，从//到行尾的所有内容都是注释。界定符对注释以/*开始，其后的所有内容都是注释，直至遇到*/为止。
- ::运算符为作用域运算符。其用处之一是访问命名空间中的名字。

# 第二章 变量和基本类型
- void 类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。
- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样大的尺寸。如果你的数值超过了int的表示范围，选用long long。
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。
- 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
- 编译器在每个字符串的结尾处添加一个空字符('\0')，因此，字符串字面值的实际长度要比它的内容多1.
- 当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。
- 引用并非对象，相反的，它只是一个已经存在的对象所起的另外一个名字
- 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
- 指针(pointer)是"指向"另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须再定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
- 指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&)
- 因为引用不是对象，没有实际地址，所有不能定义指向引用的指针
- 如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象。
- 空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。
- 引用本身并非一个对象，一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象
- 如果指针的值是0，条件取False，任何非0指针对应的条件值都是True
- void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。
- 通过*的个数可以区分指针的级别。也就是说，** 表示指向指针的指针，*** 表示指向指针的指针的指针
- 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
- 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量
- 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extend关键字
- 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象
- 把*放在const关键字之前用以说明指针是一个常量。这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值
- 用名次顶层const表示指针本身是个常量，而用名次底层const表示指针所指的对象是一个常量。
- 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响。但底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。
- C++ 11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
- 含有typedef的声明语句定义的不再是变量而是类型别名。
- 新标准用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名
- C++新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型
- 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样
- decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
- decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用
- 为了确保各个文件中类的定义一致，类通过被定义在头文件中，而且类所在头文件的名字应与类的名字一样
- 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
- #define 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义；#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真，一旦检查结果为真，则执行后序操作直至遇到#endif指令为止
- 为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写
- nullptr是表示空指针的字面值常量

# 第三章 字符串、向量和数组
- using 声明具有如下的形式：using namespace::name；一旦声明了上述语句，就可以直接访问命名空间中的名字
- 标准库类型string的引入 #include<string> using std::string;
- 在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直至遇见下一处空白为止
- 和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起。cin >> s1 >> s2  //把第一个输入读到s1中，第二个输入读到s2中
- 有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string
- 触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符
- 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题
- 当把string对象和字符字面值及字符串字面值混在一起语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string
- 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。
- 如果相对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（range for）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作。
- 标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象
- 要想使用vector，必须 #include<vector> using std::vector;
- 对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息
- 事实上，最常见的方式就是先定义一个空vector，然后当运行时获取到元素的值后再逐一添加
- C++ 11新标准还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。
- 还可以用vector对象容纳的元素数量和所有元素的统一初始化来初始化vector对象
- 通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定
- v.push_back(t) 向v的尾端添加一个值为t的元素
- 类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者string对象中的字符
- begin成员负责返回指向第一个元素（或第一个字符）的迭代器。end成员则负责返回指向容器(或string对象)“尾元素的下一位置”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后”元素
- 迭代器使用递增(++)运算符来从一个元素移动到下一个元素那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator;如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator
- 为了便于专门得到const_iterator类型的返回值，C++ 11新标准引入了两个新函数，分别是cbegin和cend。类似于begin和end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一个位置的迭代器。有所不同的是，不论vector对象(或string对象)本身是否是常量，返回值都是const_iterator
- C++语言定义了箭头运算符(->)把解引用和成员访问两个操作结合在一起
- 与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中添加元素。因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性
- 如果不清楚元素的确切个数，请使用vector
- 字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符串数组中去。
- 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值
- 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针
- C++新标准引入了两个名为begin和end的函数。正确的使用方式是将数组作为它们的参数。begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针。
- string专门提供了一个名为c_str的成员函数返回一个c风格的字符串
- 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串
- 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针

# 第四章 表达式
- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求
- 根据取余运算的定义，如果m和n是整数且n非0，则表达式(m/n)* n+m%n的求值结果与m相等。隐含的意思是，如果m%n不等于0，则它的符号和m相同。除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)
- 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象
- 条件运算符(?:)允许把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：cond?expr1:expr2；其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond得值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值
- 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合
- sizeof运算符返回一条表达式或一个类型名字所占的字节数

#第五章 语句
- 可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了
- 一般不要省略case分支最后的break语句。如果没写break语句，最好加一段注释说清楚程序的逻辑
- 如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句
- 当不确定到底要迭代多少次时，使用while循环比较合适，比如读取输入的内容就是如此。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量
- do while语句应该在括号包围起来的条件后面用一个分号表示语句结束
- break语句负责终止离它最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始继续执行
- continue语句终止最近的循环中的当前迭代并立即开始下一次迭代
- 异常检测部分使用throw表达式来表示它遇到了无法处理的问题
- 异常处理部分使用try语句块处理异常
- 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*。该字符串的目的是提供关于异常的一些文本信息
- throw表达式抛出一个异常并把控制权转移到能处理该异常的最近的catch子句

#第六章 函数
- 函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可
- 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能
- 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型
- 参数传递分为值传递和引用传递
- 如果函数无须改变形参的值，最好将其声明为常量引用
- 因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针
- 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参
- 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用
- 如果同一作用域的几个函数名字相同但形参列表不同，我们称之为重载函数
- 对于重载的函数来说，它们应该在形参数量或形参类型上有所不同；不允许两个函数除了返回类型外其他所有的要素都相同
- 形参的名字仅仅起到帮助记忆的作用，有没有它并不影响形参列表的内容
- 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量不让怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面
- assert宏使用一个表达式作为它的条件：assert(expr)；首先对expr求值，如果表达式为假(即0)，assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做

#第七章 类
- 数据抽象能帮助我们将对象的具体实现与对象所能执行的操作分离开来
- this的目的总是指向"这个"对象
- 构造函数的名字和类名相同
- 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元(friend).如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可
- 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数
- 数据成员以及仅供类本身使用而不作为接口的功能函数一般设为private
- 通常情况下，只有实现类的接口的函数才被设为public

#第八章 IO库
- iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型
- 由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用
- ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件
- 创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动被调用
- 因为调用open可能失败，进行open是否成功的检测通常是一个好习惯
- 与ifstream 关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开
- 默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式
- istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream即可从string读数据也可向string写数据
- 当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的某个单词时，通常可以使用istringstream
- 当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的

#第九章 顺序容器
- 顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应
- vector :可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢
- deque:双端队列。支持快速随机访问。在头尾位置插入/删除速度很快
- list:双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快
- forward_list:单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快
- array:固定大小数组。支持快速随机访问。不能添加或删除元素
- string:与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快
- 通常，使用vector是最好的选择，除非你有很好的理由选择其他容器
- 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
- 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque
- 标准库使用左闭合范围是因为这种范围有三种方便的性质：如果begin和end相等，则范围为空；如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素；我们可以对begin递增若干次，使得begin==end
- 当定义一个array时，除了指定元素类型，还要指定容器大小
- 比较两个容器实际上是进行元素的逐对比较
- insert函数将元素插入到迭代器所指定的位置之前
- 当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素
- 包括array在内的每个顺序容器都有一个front成员函数，而除了forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用
- 有两种不同的方式可以用来获取c中的首元素和尾元素的引用。直接的方法是调用front和back。而间接的方法是通过解引用begin返回的迭代器来获得首元素的引用，以及通过递减然后解引用end返回的迭代器来获得尾元素的引用
- 两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器
- 当在forward_list中添加或删除元素时，我们必须关注两个迭代器——一个指向我们要处理的元素，另一个指向其前驱
- 容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素
- append操作是在string末尾进行插入操作的一种简写形式；replace操作是调用erase和insert的一种简写形式
- 根据s是等于、大于还是小于参数指定的字符串，s.compare返回0、正数或负数
- 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型
- 每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器
- priority_queue：顺序容器适配器，生成一个队列，插入其中的元素不放在末尾，而是根据特定的优先级排列。默认情况下，优先级用元素类型上的小于运算符确定
