---
layout: post
title: "C++ Primer"       # Title of the post
subtitle:
modified: 2017-01-24                 # Date
date:       2017-01-24 22:00:00
author:     "随机漫步的傻瓜"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 其他
---

# 第一章 开始
- main函数的返回类型必须为int,即整数类型。在大多数系统中，main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型
- iostream库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。
- 标准库定义了4个IO对象。为了处理输入，我们使用一个名为cin的istream类型的对象。这个对象也被称为标准输入。对于输出，我们使用一个名为cout的ostream类型的对象。此对象也被称为标准输出。标准库还定义了其他两个ostream对象，名为cerr和clog。我们通常用cerr来输出警告和错误消息，因此它也被称为标准错误。而clog用来输出程序运行时的一般性消息
- <<为输出运算符，该运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即，计算结果就是我们写入给定值的那个ostream对象
- 写入endl的效果就是结束当前行
- 输入运算符(>>)与输出运算符类似，它接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。与输出运算符类似，输入运算符返回其左侧运算对象作为其计算结果。
- while(std::cin >> value)可以用来判断输入是否结束
- 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效输入时，istream对象的状态会变为无效。处于无效状态的istream对象会使得条件变为假。
- 包含来自标准库的头文件时，也应该用尖括号(<>)包围头文件名。对于不属于标准库的头文件，则用双引号("")包围
- C++有两种类型的注释：单行注释和界定符对注释。单行注释以//开始，从//到行尾的所有内容都是注释。界定符对注释以/*开始，其后的所有内容都是注释，直至遇到*/为止。
- ::运算符为作用域运算符。其用处之一是访问命名空间中的名字。

# 第二章 变量和基本类型
- void 类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。
- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样大的尺寸。如果你的数值超过了int的表示范围，选用long long。
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的。所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。
- 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
- 编译器在每个字符串的结尾处添加一个空字符('\0')，因此，字符串字面值的实际长度要比它的内容多1.
- 当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。
- 引用并非对象，相反的，它只是一个已经存在的对象所起的另外一个名字
- 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
- 指针(pointer)是"指向"另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须再定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
- 指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&)
- 因为引用不是对象，没有实际地址，所有不能定义指向引用的指针
- 如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象。
- 空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。
- 引用本身并非一个对象，一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象
- 如果指针的值是0，条件取False，任何非0指针对应的条件值都是True
- void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。
- 通过*的个数可以区分指针的级别。也就是说，** 表示指向指针的指针，*** 表示指向指针的指针的指针
- 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
- 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量
- 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extend关键字
- 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象
- 把*放在const关键字之前用以说明指针是一个常量。这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值
- 用名次顶层const表示指针本身是个常量，而用名次底层const表示指针所指的对象是一个常量。
- 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响。但底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。
- C++ 11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
- 含有typedef的声明语句定义的不再是变量而是类型别名。
- 新标准用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名
- C++新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型
- 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样
- decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
- decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用
- 为了确保各个文件中类的定义一致，类通过被定义在头文件中，而且类所在头文件的名字应与类的名字一样
- 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
- #define 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义；#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真，一旦检查结果为真，则执行后序操作直至遇到#endif指令为止
- 为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写
- nullptr是表示空指针的字面值常量

# 第三章 字符串、向量和数组
- using 声明具有如下的形式：using namespace::name；一旦声明了上述语句，就可以直接访问命名空间中的名字
- 标准库类型string的引入 #include<string> using std::string;
- 在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直至遇见下一处空白为止
- 和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写在一起。cin >> s1 >> s2  //把第一个输入读到s1中，第二个输入读到s2中
- 有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string
- 触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符
- 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题
- 当把string对象和字符字面值及字符串字面值混在一起语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string
- 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。
- 如果相对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（range for）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作。
- 标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象
- 要想使用vector，必须 #include<vector> using std::vector;
- 对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息
- 事实上，最常见的方式就是先定义一个空vector，然后当运行时获取到元素的值后再逐一添加
- C++ 11新标准还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。
- 还可以用vector对象容纳的元素数量和所有元素的统一初始化来初始化vector对象
- 通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定
- v.push_back(t) 向v的尾端添加一个值为t的元素
- 类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者string对象中的字符
- begin成员负责返回指向第一个元素（或第一个字符）的迭代器。end成员则负责返回指向容器(或string对象)“尾元素的下一位置”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后”元素
- 迭代器使用递增(++)运算符来从一个元素移动到下一个元素那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator;如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator
- 为了便于专门得到const_iterator类型的返回值，C++ 11新标准引入了两个新函数，分别是cbegin和cend。类似于begin和end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一个位置的迭代器。有所不同的是，不论vector对象(或string对象)本身是否是常量，返回值都是const_iterator
- C++语言定义了箭头运算符(->)把解引用和成员访问两个操作结合在一起
- 与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中添加元素。因为数组的大小固定,因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性
- 如果不清楚元素的确切个数，请使用vector
- 字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符串数组中去。
- 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值
- 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针
- C++新标准引入了两个名为begin和end的函数。正确的使用方式是将数组作为它们的参数。begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一位置的指针。
- string专门提供了一个名为c_str的成员函数返回一个c风格的字符串
- 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串
- 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针

# 第四章 表达式
- 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求
- 根据取余运算的定义，如果m和n是整数且n非0，则表达式(m/n)* n+m%n的求值结果与m相等。隐含的意思是，如果m%n不等于0，则它的符号和m相同。除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)
- 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象
- 条件运算符(?:)允许把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：cond?expr1:expr2；其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond得值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值
- 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合
- sizeof运算符返回一条表达式或一个类型名字所占的字节数
