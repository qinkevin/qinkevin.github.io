---
layout: post
title: "推荐系统"       # Title of the post
subtitle:
date:       2016-11-20 10:00:00
author:     "随机漫步的傻瓜"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 机器学习
---

# 推荐系统

- 在拥有大量数据集的情况下，基于物品的协作型过滤能够得出更好的结论，而且它允许我们将大量计算任务预先执行，从而使需要给与推荐的用户能够更快地得到他们所要的结果
- 两者最为显著的区别在于，物品间的比较不会像用户间的比较那么频繁变化。这意味着，无需不停地计算与每样物品最为相近的其他物品，我们可以将这样的运算任务安排在网络流量不是很大的时候进行，或者在独立于主应用之外的另一台计算机上单独进行
- 好的推荐系统不仅仅能够准确预测用户的行为，而且能够扩展用户的视野，帮助用户发现那些他们可能会感兴趣，但却不那么容易发现的东西。同时，推荐系统还要能够帮助商家将那些被淹没在长尾中的好商品介绍给可能会对他们感兴趣的用户
- 一个新的推荐算法的上线，首先需要通过离线实验证明它在很多离线指标上优于现有的算法。然后，需要通过用户调查确定它的用户满意度不低于现有的算法；最后通过在线的AB测试确定它在我们关系的指标上优于现有的算法
- 覆盖率描述一个推荐系统对物品长尾的发掘能力。最简单的定义为推荐系统能够推荐出来的物品占总物品集合的比例
- 评测推荐系统是否具有马太效应的简单办法就是使用基尼系数。
- 推荐系统要具有多样性，多样性描述了推荐列表中物品两两之间的不相似性
- 在一个网站中实现新颖性的最简单办法是，把那些用户之前在网站中对其有过行为的物品从推荐列表中过滤掉
- 提高推荐系统的信任度主要有两种方法。首先需要增加推荐系统的透明度，而增加推荐系统透明度的主要办法是提供推荐解释。其次是考虑用户的社交网络信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。
- “购买商品A的用户也经常购买的其他商品”的主要计算方法是统计购买商品A的用户购买其他商品的次数
- 基于用户行为分析的推荐算法是个性化推荐系统的重要算法，一般称为协同过滤算法
- 隐性反馈行为指的是那些不能明确反应用户喜好的行为。最具代表性的隐性反馈行为就是页面浏览行为。
- 在显性反馈中，很容易区分一个用户行为是正反馈还是负反馈，而在隐性反馈行为中，就相对比较难以确定。
- 用户活跃度和物品流行度的关系：一般认为，新用户倾向于浏览热门的物品，因为他们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品
- 基于用户的协同过滤算法，给用户推荐和他兴趣相似的其他用户喜欢的物品；基于物品的协同过滤算法，给用户推荐和他之前喜欢的物品相似的物品
- TopN推荐的任务是预测用户会不会对某部电影评分，而不是预测用户在准备对某部电影评分的前提下回给电影评多少分
- 准确率/召回率： 召回率描述有多少比例的用户—物品评分记录包含在最终的推荐列表中，而准确率描述最终的推荐列表中有多少比例是发生过的用户—物品评分记录
- 覆盖率表示最终的推荐列表中包含多大比例的物品
- 基于用户的协同过滤算法主要包括两个步骤：找到和目标用户兴趣相似的用户集合；找到这个集合中的用户喜欢，且目标用户没有听说过的物品推荐给目标用户。计算两个用户的兴趣相似度，主要是利用行为的相似度计算。
- 两个用户对冷门物品采取过同样的行为更能说明他们兴趣的相似度。
- ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度
- 基于物品的协同过滤算法主要分为两步：计算物品之间的相似度；根据物品的相似度和用户的历史行为给用户生成推荐列表
- 相似度的归一化可以提高推荐的多样性
- UserCF的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣传承
- 个性化新闻推荐更加强调抓住新闻热点，热门程度和时效性是个性化新闻推荐的重点，而个性化相对于这两点略显次要。 因此， UserCF可以给用户推荐和他有相似爱好的一群其他用户今天都在看的新闻，这样在抓住热点和时效性的同时，保证了一定程度的个性化
- 两个不同领域的最热门物品之间往往具有比较高的相似度。这个时候，仅仅靠用户行为数据是不能解决这个问题的，因为用户的行为表示这种物品之间应该相似度很高。此时，我们只能依靠引入物品的内容数据解决这个问题，比如对不同领域的物品降低权重等
- 可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。
- 隐含语义分析技术采取基于用户行为统计的自动聚类
- 隐含语义分析技术会计算出物品属于每个类的权重，因此每个物品都不是硬性地被分到某一个类中
- 隐性反馈数据集的特点是只有正样本（用户喜欢什么物品），而没有负样本（用户对什么物品不感兴趣）
- 一般认为，很热门而用户却没有行为更加代表用户对这个物品不感兴趣
- LFM模型在实际使用中有一个困难，那就是它很难实现实时的推荐。经典的LFM模型每次训练时都需要扫描所有的用户行为记录，这样才能计算出用户隐类向量（pu）和物品隐类向量（qi） 。而且LFM的训练需要在用户行为记录上反复迭代才能获得比较好的性能。因此， LFM的每次训练都很耗时，一般在实际应用中只能每天训练一次，并且计算出所有用户的推荐结果。从而LFM模型不能因为用户行为的变化实时地调整推荐结果来满足用户最近的行为
- LFM不能进行在线实时推荐，也就是说，当用户有了新的行为后，他的推荐列表不会发生变化。 UserCF和ItemCF在线服务算法需要将相关表缓存在内存中，然后可以在线进行实时的预测
- 基于随机游走的PersonalRank算法： 假设要给用户u进行个性化推荐，可以从用户u对应的节点vu开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率α决定是继续游走，还是停止这次游走并从vu节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。这样，经过很多次随机游走后，每个物品节点被访问到的概率会收敛到一个数。最终的推荐列表中物品的权重就是物品节点的访问概率。
- 如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是冷启动的问题
- Nadav Golbandi的算法首先会从所有用户中找到具有最高区分度的物品i，然后将用户分成3类。然后在每类用户中再找到最具区分度的物品，然后将每一类用户又各自分为3类，也就是将总用户分成9类，然后这样继续下去，最终可以通过对一系列物品的看法将用户进行分类。而在冷启动时，我们从根节点开始询问用户对该节点物品的看法，然后根据用户的选择将用户放到不同的分枝，直到进入最后的叶子节点，此时我们就已经对用户的兴趣有了比较清楚的了解，从而可以开始对用户进行比较准确地个性化推荐
- 计算音乐之间的相似度是比较困难的。首先，音乐是多媒体，如果从音频分析入手计算歌曲之间的相似度，则技术门槛很高，而且也很难计算得令人满意。其次，仅仅利用歌曲的专辑、歌手等属性信息很难获得令人满意的歌曲相似度表，因为一名歌手、一部专辑往往只有一两首好歌
- 标签系统中的推荐问题主要有以下两个：如何利用用户打标签的行为为其推荐物品；如何在用户给物品打标签时为其推荐适合该物品的标签
- 标签扩展的本质是对每个标签找到和它相似的标签，也就是计算标签之间的相似度。对于新用户或者新物品，需要对标签集合做扩展。 最简单
的相似度可以是同义词。如果有一个同义词词典，就可以根据这个词典进行标签扩展。如果没有这个词典，我们可以从数据中统计出标签的相似度。
- 标签清理的另一个重要意义在于将标签作为推荐解释。如果我们要把标签呈现给用户，将其作为给用户推荐某一个物品的解释，对标签的质量要求就很高。首先，这些标签不能包含没有意义的停止词或者表示情绪的词，其次这些推荐解释里不能包含很多意义相同的词语。
- 我们知道，要让用户直观上感觉推荐结果有道理是很困难的，而豆瓣将推荐结果的可解释性拆分成了两部分，首先让用户觉得标签云是有道理的，然后让用户觉得从某个标签推荐出某本书也是有道理的。因为生成让用户觉得有道理的标签云比生成让用户觉得有道理的推荐图书更加简单，标签和书的关系就更容易让用户觉得有道理，从而让用户最终觉得推荐出来的书也是很有道理的
- 用户对标签的兴趣和标签与物品的相关度
- 给用户推荐标签有两个好处：方便用户输入标签、提高标签质量
- 给用户推荐标签时可以将该物品上最热门的标签和用户经常使用的标签结合起来，加权并归一化
- 用户所处的上下文（context） ，这些上下文包括用户访问推荐系统的时间、地点、心情等 ，对于提高推荐系统的准确性是非常重要的
- 推荐算法需要平衡考虑用户的近期行为和长期行为，既要让推荐列表反应出用户近期行为所体现的兴趣变化，又不能让推荐列表完全受用户近期行为的影响，要保证推荐列表对用户兴趣预测的延续性
- 推荐系统每天推荐结果的变化程度被定义为推荐系统的时间多样性
- 提高推荐结果的时间多样性需要分两步解决：首先，需要保证推荐系统能够在用户有了新的行为后及时调整推荐结果，使推荐结果满足用户最近的兴趣；其次，需要保证推荐系统在用户没有新的行为时也能够经常变化一下结果，具有一定的时间多样性
- 如果用户没有行为，如何保证给用户的推荐结果具有一定的时间多样性呢？一般的思路有以下几种：在生成推荐结果时加入一定的随机性；记录用户每天看到的推荐结果，然后在每天给用户进行推荐时，对他前几天看到过很多次的推荐结果进行适当地降权； 每天给用户使用不同的推荐算法
- 在预测用户现在的兴趣时，应该加重用户近期行为的权重，优先给用户推荐那些和他近期喜欢的物品相似的物品
- 社会化推荐之所以受到很多网站的重视，是缘于如下优点： 好友推荐可以增加推荐的信任度； 社交网络可以解决冷启动问题
- 在社交网络中要考虑 好友和用户的熟悉程度以及兴趣相似度
- 在社交网站中存在两种关系，一种是用户对物品的兴趣关系，一种是用户之间的社交网络关系。
- 在社交网络中，除了常见的、用户和用户之间直接的社交网络关系，还有一种关系，即两个用户属于同一个社群
- 基于好友的好友推荐算法可以用来给用户推荐他们在现实社会中互相熟悉，而在当前社交网络中没有联系的其他用户
- 推荐系统需要由多个推荐引擎组成，每个推荐引擎负责一类特征和一种任务，而推荐系统的任务只是将推荐引擎的结果按照一定权重或者优先级合并、排序然后返回
- 一般的标准就是用户付出代价越大的行为权重越高
- 推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重
- 特征—物品相关推荐模块还可以接受一个候选物品集合。候选物品集合的目的是保证推荐结果只包含候选物品集合中的物品。它的应用场合一般是产品需求希望将某些类型的电视剧推荐给用户。 但如果是要在一个很大的候选物品集合中给用户推荐物品，那么可以考虑直接在初始推荐列表中
过滤掉不在候选物品集合中物品的方法。
- 为了提高用户的体验，推荐系统需要给用户推荐质量好的物品，那么对于一些绝大多数用户评论都很差的物品，推荐系统需要过滤掉。这种过滤一般以用户的历史评分为依据，比如过滤掉平均分在2分以下的物品
- 要提高推荐结果的多样性，就需要让推荐结果尽量来自不同的特征，具有不同的推荐理由，而不是所有的推荐结果都对应一个理由
- 评分预测问题就是如何通过已知的用户历史评分记录预测未知的用户评分记录
- 关于如何划分训练集和测试集，如果是和时间无关的预测任务，可以以均匀分布随机划分数据集，即对每个用户，随机选择一些评分记录作为测试集，剩下的记录作为测试集。如果是和时间相关的任务，那么需要将用户的旧行为作为训练集，将用户的新行为作为测试集。
- 基于用户的邻域算法认为预测一个用户对一个物品的评分，需要参考和这个用户兴趣相似的用户对该物品的评分
- 基于物品的邻域算法在预测用户u对物品i的评分时，会参考用户u对和物品i相似的其他物品的评分
- 一般认为，如果补全后矩阵的特征值和补全之前矩阵的特征值相差不大，就算是扰动比较小。所以，最早的矩阵分解模型就是从数学上的SVD（奇异值分解）开始的。
- 推荐系统只有在用户遇到信息过载时才必要
