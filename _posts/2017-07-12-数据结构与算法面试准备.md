---
layout:     post
title:      "数据结构与算法面试准备"
subtitle:
date:       2017-7-12 11:00:00
author:     "随机漫步的傻瓜"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 其他
---
1. 海量数据处理面试题：分而治之、hash统计、堆（归并排序）
2. 统计环中结点个数n:设置一块一慢两个指针，如果链表中有环，两指针必定在环中某个结点处相遇。从此结点开始计数，当再次到达此结点时，就可以得到环中结点数
3. 链表中环的入口地址：设置两个指针p1和p2，如果环中有n个结点，指针p1先向前移动n个结点，然后两个指针以相同速度向前移动，当两个指针相遇的结点就是环的入口结点。
4. 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值：使用双向队列可以满足要求，滑动窗口的最大值总是保存在队列首部，队列里面的数据总是从大到小排列。当遇到比当前滑动窗口最大值更大的值时，则将队列清空，并将新的最大值插入到队列中。如果遇到的值比当前最大值小，则直接插入到队列尾部。每次移动的时候需要判断当前的最大值是否在有效范围，如果不在，则需要将其从队列中删除。由于每个元素最多进队和出队各一次，因此该算法时间复杂度为O(N)。
5. 数组中重复的数字：对于给定的数组进行重排。对于下标为i的元素：如果a[i] == i，扫描下一个元素；如果不相等将a[i]与a[a[i]]进行比较，若是相等则找到了一个重复的数字，若没有，那么对于数字进行交换，依次进行
6. 合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率
7. 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0
8. 如果面试题是关于n位的整数并且没有限定n的取值范围，或者是输入任意大小的整数，那么这个题目很有可能是需要考虑大数问题的。字符串是一个简单、有效的表示大数的方法
9. 求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。为了解决这个问题，我们也可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走的快的指针走到链表的末尾时，走的慢的指针正好在链表的中间
10. 判断一个单向链表是否形成了环形结构。和前面的问题一样，定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走的快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不是环形链表
11. 不管是广度优先遍历一个有向图还是一颗树，都要用到队列。第一步我们把起始节点（对树而言是根节点）放入队列中。接下来每一次从队列的头部取出一个结点，遍历这个结点之后把从它能到达的节点（对树而言是子节点）都依次放入队列。我们重复这个遍历过程，直到队列中的节点全部被遍历为止
12. 如果面试题是要求处理一棵二叉树的遍历序列，我们可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列
13. 如果需要判断多个字符是不是在某个字符串里出现过或者统计多个字符在某个字符串中出现的次数，我们可以考虑基于数组创建一个简单的哈希表。这样可以用很小的空间消耗换来时间效率的提升
14. atoi用来把一个字符串转为一个数字
15. n个骰子的点数：假设f(m,n)表示投第m个骰子时，点数之和n出现的次数,投第m个骰子时的点数之和只与投第m-1个骰子时有关。递归方程：f(m,n)=f(m-1,n-1)+f(m-1,n-2)+f(m-1,n-3)+f(m-1,n-4)+f(m-1,n-5)+f(m-1,n-6)，表示本轮点数和为n出现次数等于上一轮点数和为n-1，n-2，n-3，n-4，n-5，n-6出现的次数之和。初始条件：第一轮的f(1),f(2),f(3),f(4),f(5),f(6)均等于1.
16. 输入一个正数S，打印出所有和为S的连续正数序列（至少有两个数）：考虑两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2.如果从small到big的序列的和大于S，可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列的和小于S，可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+S）/2为止。
17. 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。依然从头到尾异或所有的数字，这样得到的结果实际上就是两个只出现了一次的数字异或的结果，我们在异或后的结果中找出其二进制中最右边为1的位，该位既然为1，说明异或的两个数字对应的该位肯定不同，必定一个为1，一个为0，因此我们可以考虑根据此位是否为1来划分这两个子数组，这样两个只出现一次的数字就分开了，但我们还要保证出现两次的数字都分到同一个子数组中，肯定不能两个重复的数字分在两个不同的子数组中，这样得到的结果是不对的，很明显，相同的数字相同的位上的值是相同的，要么都为1，要么都为0，因此我们同样可以通过判断该位是否为1来将这些出现两次的数字划分到同一个子数组中，该位如果为1，就分到一个子数组中，如果为0，就分到另一个子数组中。这样就能保证每个子数组中只有一个出现一次的数字，其他的数字都出现两次，分别全部异或即可得到这两个只出现一次的数字。时间复杂度为O(n)。
18. 二路归并排序：递归。
```c++
void MergeSort(SqList &L,int low,int high)  
{  
    int mid;  
    if(low<high)  
    {  
        mid=(low+high)/2;  
        MergeSort(L,low,mid);  
        MergeSort(L,mid+1,high);  
        Merge(L,low,mid,high);  
    }  
}  
```
19. 二分求幂：n为奇数，n为偶数
20. 主元素问题：设T[0:n-1]是n个元素的数组。对任意一个元素x，设S(x)={i|T[i]=x}。当|S(x)|〉n/2时，称x为T的主元素。设计一个线性时间算法，确定T[0:n-1]是否有一个主元素

```c++
void majority_2(int *a, int len)
{
    int seed = a[0];
    int count = 1;

    for (int i = 1; i < len; i++)
    {
        if (seed == a[i])
            count++;
        else
        {
            if (count == 0)
            {
                seed = a[i];
                count = 1;
            }
            else
                count--;
        }
    }

    // justify seed..
    count = 0;
    for (int i = 0; i < len; i++)
    {
        if (a[i] == seed)
            count++;
    }
    if (count > len/2)
        cout<<seed<<endl;
    // no main elements in the array...
    else cout<<"none"<<endl;

}
```
